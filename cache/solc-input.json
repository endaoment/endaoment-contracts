{
  "language": "Solidity",
  "sources": {
    "contracts/endaomentAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/*\nENDAOMENT V0.1 ADMIN CONTRACT: \n    EndaomentAdmin acts as a admin user state gatekeeper for the FundFactory, Fund, OrgFactory and Org Contracts. \n    On deployment, the admin is set by the deployer. Once set, only the admin can change the admin role. \n\n*/\n\n\npragma solidity ^0.5.0;\n\ninterface EndaomentAdminInterface {\n  event RoleModified(Role indexed role, address account);\n  event RolePaused(Role indexed role);\n  event RoleUnpaused(Role indexed role);\n\n  enum Role {\n    ADMIN,\n    PAUSER,\n    ACCOUNTANT,\n    REVIEWER\n    \n  }\n\n  struct RoleStatus {\n    address account;\n    bool paused;\n  }\n  \n  function setRole(Role role, address account) external;\n\n  function removeRole(Role role) external;\n\n  function pause(Role role) external;\n\n  function unpause(Role role) external;\n\n  function isPaused(Role role) external view returns (bool paused);\n\n  function isRole(Role role) external view returns (bool hasRole);\n  \n  function getAdmin() external view returns (address admin);\n\n  function getPauser() external view returns (address pauser);\n  \n  function getAccountant() external view returns (address accountant);\n  \n  function getReviewer() external view returns (address reviewer);\n    \n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n *\n * In order to transfer ownership, a recipient must be specified, at which point\n * the specified recipient can call `acceptOwnership` and take ownership.\n */\ncontract TwoStepOwnable {\n  address private _owner;\n  address private _newPotentialOwner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Initialize contract by setting transaction submitter as initial owner.\n   */\n  constructor() internal {\n    _owner = tx.origin;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function getOwner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\n    _;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isOwner() public view returns (bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows a new account (`newOwner`) to accept ownership.\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(\n      newOwner != address(0),\n      \"TwoStepOwnable: new potential owner is the zero address.\"\n    );\n\n    _newPotentialOwner = newOwner;\n  }\n\n  /**\n   * @dev Cancel a transfer of ownership to a new account.\n   * Can only be called by the current owner.\n   */\n  function cancelOwnershipTransfer() public onlyOwner {\n    delete _newPotentialOwner;\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to the caller.\n   * Can only be called by a new potential owner set by the current owner.\n   */\n  function acceptOwnership() public {\n    require(\n      msg.sender == _newPotentialOwner,\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\n    );\n\n    delete _newPotentialOwner;\n\n    emit OwnershipTransferred(_owner, msg.sender);\n\n    _owner = msg.sender;\n  }\n}\n\ncontract EndaomentAdmin is EndaomentAdminInterface, TwoStepOwnable {\n  // Maintain a role status mapping with assigned accounts and paused states.\n  mapping(uint256 => RoleStatus) private _roles;\n  \n  /**\n   * @notice Set a new account on a given role and emit a `RoleModified` event\n   * if the role holder has changed. Only the owner may call this function.\n   * @param role The role that the account will be set for.\n   * @param account The account to set as the designated role bearer.\n   */\n  function setRole(Role role, address account) external onlyOwner {\n    require(account != address(0), \"Must supply an account.\");\n    _setRole(role, account);\n  }\n\n  /**\n   * @notice Remove any current role bearer for a given role and emit a\n   * `RoleModified` event if a role holder was previously set. Only the owner\n   * may call this function.\n   * @param role The role that the account will be removed from.\n   */\n  function removeRole(Role role) external onlyOwner {\n    _setRole(role, address(0));\n  }\n  \n  /**\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\n   * the owner or the designated pauser may call this function. Also, bear in\n   * mind that only the owner may unpause a role once paused.\n   * @param role The role to pause.\n   */\n  function pause(Role role) external onlyAdminOr(Role.PAUSER) {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n    require(!storedRoleStatus.paused, \"Role in question is already paused.\");\n    storedRoleStatus.paused = true;\n    emit RolePaused(role);\n  }\n\n  /**\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\n   * Only the owner may call this function.\n   * @param role The role to pause.\n   */\n  function unpause(Role role) external onlyOwner {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n    require(storedRoleStatus.paused, \"Role in question is already unpaused.\");\n    storedRoleStatus.paused = false;\n    emit RoleUnpaused(role);\n  }\n  \n  /**\n   * @notice External view function to check whether or not the functionality\n   * associated with a given role is currently paused or not. The owner or the\n   * pauser may pause any given role (including the pauser itself), but only the\n   * owner may unpause functionality. Additionally, the owner may call paused\n   * functions directly.\n   * @param role The role to check the pause status on.\n   * @return paused A boolean to indicate if the functionality associated with\n   * the role in question is currently paused.\n   */\n  function isPaused(Role role) external view returns (bool paused) {\n    paused = _isPaused(role);\n  }\n\n  /**\n   * @notice External view function to check whether the caller is the current\n   * role holder.\n   * @param role The role to check for.\n   * @return hasRole A boolean indicating if the caller has the specified role.\n   */\n  function isRole(Role role) external view returns (bool hasRole) {\n    hasRole = _isRole(role);\n  }\n\n  /**\n   * @notice External view function to check the account currently holding the\n   * admin role. The admin can execute and cancel limit orders.\n   * @return admin The address of the current admin, or the null\n   * address if none is set.\n   */\n  function getAdmin() external view returns (\n    address admin\n  ) {\n    admin = _roles[uint256(Role.ADMIN)].account;\n  }\n\n  /**\n   * @notice External view function to check the account currently holding the\n   * pauser role. The pauser can pause any role from taking its standard action,\n   * though the owner will still be able to call the associated function in the\n   * interim and is the only entity able to unpause the given role once paused.\n   * @return pauser The address of the current pauser, or the null address if\n   * none is set.\n   */\n  function getPauser() external view returns (address pauser) {\n    pauser = _roles[uint256(Role.PAUSER)].account;\n  }\n  \n  /**\n   * @notice External view function to check the account currently holding the\n   * accountant role.\n   */\n  function getAccountant() external view returns (address accountant) {\n    accountant = _roles[uint256(Role.ACCOUNTANT)].account;\n  }\n  \n  /**\n   * @notice External view function to check the account currently holding the\n   * reviewer role.\n   */\n  function getReviewer() external view returns (address reviewer) {\n    reviewer = _roles[uint256(Role.REVIEWER)].account;\n  }\n  \n  /**\n   * @notice Private function to set a new account on a given role and emit a\n   * `RoleModified` event if the role holder has changed.\n   * @param role The role that the account will be set for.\n   * @param account The account to set as the designated role bearer.\n   */\n  function _setRole(Role role, address account) private {\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n\n    if (account != storedRoleStatus.account) {\n      storedRoleStatus.account = account;\n      emit RoleModified(role, account);\n    }\n  }\n\n  /**\n   * @notice Private view function to check whether the caller is the current\n   * role holder.\n   * @param role The role to check for.\n   * @return hasRole A boolean indicating if the caller has the specified role.\n   */\n  function _isRole(Role role) private view returns (bool hasRole) {\n    hasRole = msg.sender == _roles[uint256(role)].account;\n  }\n\n  /**\n   * @notice Private view function to check whether the given role is paused or\n   * not.\n   * @param role The role to check for.\n   * @return paused A boolean indicating if the specified role is paused or not.\n   */\n  function _isPaused(Role role) private view returns (bool paused) {\n    paused = _roles[uint256(role)].paused;\n  }\n  \n    /**\n   * @notice Modifier that throws if called by any account other than the owner\n   * or the supplied role, or if the caller is not the owner and the role in\n   * question is paused.\n   * @param role The role to require unless the caller is the owner. Permitted\n   * roles are bot commander (0) and pauser (1).\n   */\n  modifier onlyAdminOr(Role role) {\n    if (!isOwner()) {\n      require(_isRole(role), \"Caller does not have a required role.\");\n      require(!_isPaused(role), \"Role in question is currently paused.\");\n    }\n    _;\n  }\n\n}\n\n\n"
    },
    "contracts/fundFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\nENDAOMENT V0.1 DONOR-ADVISED FUND CONTRACTS: \n*/\n\npragma solidity ^0.5.0;\n\n\n// INTERFACES\ninterface OrgFactory {\n    function getAllowedOrgs(address recipient) external view returns (bool);\n}\n\ninterface EndaomentAdmin {\n    enum Role {\n    ADMIN,\n    PAUSER,\n    ACCOUNTANT,\n    REVIEWER\n    \n  }\n    struct RoleStatus {\n    address account;\n    bool paused;\n  }\n \n    function getAdmin() external view returns (address);\n    function getAccountatnt() external view returns (address);\n    function getReviewer() external view returns (address);\n    function isPaused(Role role) external view returns (bool);\n    \n}\n\ninterface ERC20 {\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function transfer(address to, uint tokens) external returns (bool success);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n}\n\n// LIBRARY \nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n\n    return a - b;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"SafeMath: division by zero\");\n    return a / b;\n  }\n}\n\n\n// FUND FACTORY CONTRACT\n/**\n * @title FundFactory\n * @author rheeger\n * @notice FundFactory is a contract that allows the EndaomentAdmin to \n * instantiate new Fund contracts. It also provides for fetching of \n * individual Org contract addresses as well as a list of all \n * allowedOrgs. \n */\ncontract FundFactory {\n    \n    // ========== STATE VARIABLES ==========\n    \n    Fund[] public createdFunds;\n    event fundCreated(address indexed newAddress);\n    \n    \n    // ========== Admin Management ==========\n    \n        /**\n         * @notice onlyAdmin checks that the caller is the EndaomentAdmin\n         * @param adminContractAddress is the supplied EndaomentAdmin contract address\n         */\n        modifier onlyAdmin(address adminContractAddress) {\n        EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n        require(msg.sender == x.getAdmin());\n        _;\n        }\n     \n        /**\n        * @notice onlyAdminOrRole checks that the caller is either the Admin or the provided role.\n        * @param adminContractAddress supplied EndaomentAdmin address\n        * @param role The role to require unless the caller is the owner. Permitted\n        * roles are admin (0), accountant (2), and reviewer (3).\n        */     \n        modifier onlyAdminOrRole(address adminContractAddress, EndaomentAdmin.Role role) {\n            EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n            if (msg.sender != x.getAdmin()) {\n                if (!x.isPaused(role)) {\n                     if (role == EndaomentAdmin.Role.ACCOUNTANT ){\n                         require(msg.sender == x.getAccountatnt());\n                    }\n                     if (role == EndaomentAdmin.Role.REVIEWER ){\n                         require(msg.sender == x.getReviewer());\n                     }\n                }\n                \n            require(msg.sender == x.getAdmin());\n          }\n          _;\n         }\n     \n    // ========== CONSTRUCTOR ==========    \n    \n    /**\n    * @notice Create new Fund Factory\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    constructor(address adminContractAddress) public onlyAdmin(adminContractAddress) {\n        \n    }\n        \n    // ========== Fund Creation & Management ==========\n\n    /**\n    * @notice  Create new Fund\n    * @param managerAddress The address of the Fund's Primary Advisor\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    function createFund(address managerAddress, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.ACCOUNTANT){\n        Fund newFund = new Fund(managerAddress);\n        createdFunds.push(newFund);\n        emit fundCreated(address(newFund));\n    }\n\n    function countFunds() public view returns (uint) {\n        return createdFunds.length;\n    }\n\n    function getFund(uint index) public view returns (address) {\n        return address(createdFunds[index-1]); \n    }\n\n}\n\n\n\n// FUND CONTRACT\n/**\n * @title Fund\n * @author rheeger\n * @notice Fund is a contract that serves as an on-chain US Donor-Advised Fund.\n * It holds the proceeds of gifted cryptocurrency as ERC20 tokens, \n * and allows for the manager to submit Grant reccomendations to the contract. \n * The EndaomentAdmin can then chose to approve the Grant reccomendation, triggering\n * a SafeMath transfer of a 1% fee to the EndaomentAdmin and the remainder to the \n * recipient Org contract.\n */\ncontract Fund {\n    using SafeMath for uint256;\n\n    // ========== STATE VARIABLES ==========\n    \n    struct Grant {\n        string description;\n        uint value;\n        address recipient;\n        bool complete;\n    }\n    \n    address public manager;\n    address public admin;\n    mapping(address => bool) public contributors;\n    Grant[] public grants;\n    uint public totalContributors;\n\n\n    // ========== CONSTRUCTOR ==========    \n    \n        /**\n        * @notice Create new Fund\n        * @param creator Address of the Fund's Primary Advisor\n        */\n        constructor(address creator) public {\n            manager = creator;\n    \n        }\n    \n\n    // ========== Admin Management ==========\n    \n        modifier restricted() {\n        require(msg.sender == manager);\n        _;\n        }\n        \n        /**\n         * @notice onlyAdmin checks that the caller is the EndaomentAdmin\n         * @param adminContractAddress is the supplied EndaomentAdmin contract address\n         */\n        modifier onlyAdmin(address adminContractAddress) {\n        EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n        require(msg.sender == x.getAdmin());\n        _;\n        }\n     \n        /**\n        * @notice onlyAdminOrRole checks that the caller is either the Admin or the provided role.\n        * @param adminContractAddress supplied EndaomentAdmin address\n        * @param role The role to require unless the caller is the owner. Permitted\n        * roles are admin (0), accountant (2), and reviewer (3).\n        */     \n        modifier onlyAdminOrRole(address adminContractAddress, EndaomentAdmin.Role role) {\n            EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n            if (msg.sender != x.getAdmin()) {\n                if (!x.isPaused(role)) {\n                     if (role == EndaomentAdmin.Role.ACCOUNTANT ){\n                         require(msg.sender == x.getAccountatnt());\n                    }\n                     if (role == EndaomentAdmin.Role.REVIEWER ){\n                         require(msg.sender == x.getReviewer());\n                     }\n                }\n                \n            require(msg.sender == x.getAdmin());\n          }\n          _;\n         }\n    \n        \n    // ========== Fund Management & Info ==========\n    \n    /**\n     * @notice Change Fund Primary Advisor\n     * @param  newManager The address of the new PrimaryAdvisor.\n     * @param  adminContractAddress Address of the EndaomentAdmin contract. \n     */\n    function changeManager (address newManager, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.REVIEWER){\n        manager = newManager;\n    }\n\n    function checkRecipient(address recipient, address orgFactoryContractAddress) public view returns (bool) {\n        OrgFactory x = OrgFactory ( orgFactoryContractAddress );\n    \n        return x.getAllowedOrgs(recipient);\n\n    }\n\n     function getSummary(address tokenAddress) public view returns (uint, uint, uint, address) {\n            ERC20 t = ERC20(tokenAddress);\n            uint bal = t.balanceOf(address(this));\n\n        return (\n            bal,\n            address(this).balance,\n            grants.length,\n            manager\n        );\n    }\n    \n    /**\n     * @notice Create new Grant Reccomendation\n     * @param  description The address of the Owner.\n     * @param  value The value of the grant in base units.\n     * @param  recipient The address of the recieving organization's contract.\n     * @param  orgFactoryContractAddress Address of the orgFactory Contract.\n     */\n    function createGrant(string memory description, uint256 value, address recipient, address orgFactoryContractAddress) public restricted {\n        require(checkRecipient(recipient, orgFactoryContractAddress) == true);\n\n        Grant memory newGrant = Grant({\n            description: description,\n            value: value,\n            recipient: recipient,\n            complete: false\n        });\n\n        grants.push(newGrant);\n    }\n\n    /**\n     * @notice Approve Grant Reccomendation\n     * @param  index This Grant's index position\n     * @param  tokenAddress The stablecoin's token address. \n     * @param  adminContractAddress Address of the EndaomentAdmin contract. \n     */\n    function finalizeGrant(uint index, address tokenAddress, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.ACCOUNTANT){\n        EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n        admin = x.getAdmin();\n        Grant storage grant = grants[index];\n        require(grant.complete == false);\n        ERC20 t = ERC20(tokenAddress);\n        \n        \n\n        //Process fees:\n        uint256 fee = (grant.value)/100;\n        uint256 finalGrant = (grant.value * 99)/100;\n        t.transfer(admin, fee);\n        \n        t.transfer(grant.recipient, finalGrant);\n\n        grant.complete = true;\n    }\n\n\n    function getGrantsCount() public view returns (uint) {\n        return grants.length;\n    }\n}"
    },
    "contracts/orgFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\nENDAOMENT V0.1 ORGANIZATION CONTRACTS: \n*/\n\npragma solidity ^0.5.0;\n\n\n// INTERFACES\ninterface EndaomentAdmin {\n    enum Role {\n    ADMIN,\n    PAUSER,\n    ACCOUNTANT,\n    REVIEWER\n    \n  }\n    struct RoleStatus {\n    address account;\n    bool paused;\n  }\n \n    function getAdmin() external view returns (address);\n    function getAccountatnt() external view returns (address);\n    function getReviewer() external view returns (address);\n    function isPaused(Role role) external view returns (bool);\n    \n}\n\ninterface ERC20 {\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function transfer(address to, uint tokens) external returns (bool success);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n}\n\n// LIBRARY \nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n\n    return a - b;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"SafeMath: division by zero\");\n    return a / b;\n  }\n}\n\n//ORG FACTORY CONTRACT\n/**\n * @title OrgFactory\n * @author rheeger\n * @notice OrgFactory is a contract that allows the EndaomentAdmin to \n * instantiate new Org contracts. It also provides for fetching of \n * individual Org contract addresses as well as a list of all \n * allowedOrgs. \n */\ncontract OrgFactory {\n    \n    // ========== STATE VARIABLES==========\n\n    Org[] public deployedOrgs;\n    mapping(address => bool) public allowedOrgs;\n    event orgCreated(address indexed newAddress);\n    \n\n    // ========== Admin Management ==========\n    \n        /**\n         * @notice onlyAdmin checks that the caller is the EndaomentAdmin\n         * @param adminContractAddress is the supplied EndaomentAdmin contract address\n         */\n        modifier onlyAdmin(address adminContractAddress) {\n        EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n        require(msg.sender == x.getAdmin());\n        _;\n        }\n     \n        /**\n        * @notice onlyAdminOrRole checks that the caller is either the Admin or the provided role.\n        * @param adminContractAddress supplied EndaomentAdmin address\n        * @param role The role to require unless the caller is the owner. Permitted\n        * roles are admin (0), accountant (2), and reviewer (3).\n        */     \n        modifier onlyAdminOrRole(address adminContractAddress, EndaomentAdmin.Role role) {\n            EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n            if (msg.sender != x.getAdmin()) {\n                if (!x.isPaused(role)) {\n                     if (role == EndaomentAdmin.Role.ACCOUNTANT ){\n                         require(msg.sender == x.getAccountatnt());\n                    }\n                     if (role == EndaomentAdmin.Role.REVIEWER ){\n                         require(msg.sender == x.getReviewer());\n                     }\n                }\n                \n            require(msg.sender == x.getAdmin());\n          }\n          _;\n         }  \n      \n    // ========== CONSTRUCTOR ==========    \n    \n    /**\n    * @notice Create new Org Factory\n    * @param adminContractAddress Address of EndaomentAdmin contract. \n    */\n    constructor(address adminContractAddress) public onlyAdmin(adminContractAddress){\n        \n    }\n\n\n    // ========== Org Creation & Management ==========\n\n    /**\n    * @notice  Create new Org Contract\n    * @param ein The U.S. Tax Identification Number for the Organization\n    * @param adminContractAddress Contract address for Endaoment Admin\n    */\n    function createOrg(uint ein, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.ACCOUNTANT){\n        Org newOrg = new Org(ein, adminContractAddress);\n        deployedOrgs.push(newOrg);\n        allowedOrgs[address(newOrg)] = true;\n        emit orgCreated(address(newOrg));\n    }\n\n    function countDeployedOrgs() public view returns (uint) {\n        return deployedOrgs.length;\n    }\n\n    function getDeployedOrg(uint index) public view returns (address) {\n        return address(deployedOrgs[index-1]);\n    }\n\n    function getAllowedOrgs(address Org) public view returns (bool){\n        return allowedOrgs[Org];\n    }\n}\n\n//ORG CONTRACT\n/**\n * @title Org\n * @author rheeger\n * @notice Org is a contract that serves as a smart wallet for US nonprofit\n * organizations. It holds the organization's federal Tax ID number as taxID, \n * and allows for an address to submit a Claim struct to the contract whereby \n * the organization can direct recieved grant awards from Endaoment Funds.\n */\ncontract Org {\n    using SafeMath for uint256;\n\n    // ========== STATE VARIABLES ==========\n    \n    struct Claim {\n        string firstName;\n        string lastName;\n        string eMail;\n        address desiredWallet;\n        bool filesSubmitted;\n    }\n\n    uint public taxId;\n    address public orgWallet;\n    Claim[] public claims;\n    event cashOutComplete(uint cashOutAmount);\n\n\n    // ========== CONSTRUCTOR ==========    \n    \n    /**\n    * @notice Create new Organization Contract\n    * @param ein The U.S. Tax Identification Number for the Organization\n    * @param adminContractAddress Contract Address for Endaoment Admin\n    */\n    constructor(uint ein, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.ACCOUNTANT){\n        taxId = ein;\n    }\n\n\n    // ========== Admin Management ==========\n    \n        /**\n         * @notice onlyAdmin checks that the caller is the EndaomentAdmin\n         * @param adminContractAddress is the supplied EndaomentAdmin contract address\n         */\n        modifier onlyAdmin(address adminContractAddress) {\n        EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n        require(msg.sender == x.getAdmin());\n        _;\n        }\n     \n        /**\n        * @notice onlyAdminOrRole checks that the caller is either the Admin or the provided role.\n        * @param adminContractAddress supplied EndaomentAdmin address\n        * @param role The role to require unless the caller is the owner. Permitted\n        * roles are admin (0), accountant (2), and reviewer (3).\n        */     \n        modifier onlyAdminOrRole(address adminContractAddress, EndaomentAdmin.Role role) {\n            EndaomentAdmin x = EndaomentAdmin(adminContractAddress);\n            \n            if (msg.sender != x.getAdmin()) {\n                if (!x.isPaused(role)) {\n                     if (role == EndaomentAdmin.Role.ACCOUNTANT ){\n                         require(msg.sender == x.getAccountatnt());\n                    }\n                     if (role == EndaomentAdmin.Role.REVIEWER ){\n                         require(msg.sender == x.getReviewer());\n                     }\n                }\n                \n            require(msg.sender == x.getAdmin());\n          }\n          _;\n         }\n\n    // ========== Org Management & Info ==========\n    \n    /**\n     * @notice Create Organization Claim\n     * @param  fName First name of Administrator\n     * @param  lName Last name of Administrator\n     * @param  fSub Information Submitted successfully.\n     * @param  eMail Email contact for Organization Administrator.\n     * @param  orgAdminAddress Wallet address of Organization's Administrator.\n     */\n    function claimRequest(string memory fName, string memory lName, bool fSub, string memory eMail, address orgAdminAddress) public {\n        require (fSub == true);\n        require (msg.sender == orgAdminAddress);\n        \n        Claim memory newClaim = Claim({\n            firstName: fName,\n            lastName: lName,\n            eMail: eMail,\n            desiredWallet: msg.sender,\n            filesSubmitted: true\n        });\n\n        claims.push(newClaim);\n    }\n\n    /**\n     * @notice Approving Organization Claim \n     * @param  index Index value of Claim.\n     * @param adminContractAddress Contract Address for Endaoment Admin\n     */\n    function approveClaim(uint index, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.REVIEWER){\n        Claim storage claim = claims[index]; \n        \n        setOrgWallet(claim.desiredWallet, adminContractAddress);\n    }\n\n    /**\n     * @notice Cashing out Organization Contract \n     * @param  desiredWithdrawlAddress Destination for withdrawl\n     * @param tokenAddress Stablecoin address of desired token withdrawl\n     * @param adminContractAddress Contract Address for Endaoment Admin\n     */\n    function cashOutOrg(address desiredWithdrawlAddress, address tokenAddress, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.ACCOUNTANT){\n        ERC20 t = ERC20(tokenAddress);\n        uint256 cashOutAmount = t.balanceOf(address(this));\n\n        t.transfer(desiredWithdrawlAddress, cashOutAmount);\n        emit cashOutComplete(cashOutAmount);\n    }\n\n    function setOrgWallet(address providedWallet, address adminContractAddress) public onlyAdminOrRole(adminContractAddress, EndaomentAdmin.Role.REVIEWER){\n        orgWallet = providedWallet;\n    }\n\n     function getTokenBalance(address tokenAddress) public view returns (uint) {\n            ERC20 t = ERC20(tokenAddress);\n            uint256 bal = t.balanceOf(address(this));\n\n        return bal;\n     }\n\n       function getClaimsCount() public view returns (uint) {\n        return claims.length;\n    }\n\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}